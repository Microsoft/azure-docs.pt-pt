---
title: A funcionalidade de mapeamento de fluxo de dados do Azure Data Factory com funções de expressão
description: Saiba mais sobre as funções de expressão no mapeamento de fluxo de dados.
author: kromerm
ms.author: makromer
ms.service: data-factory
ms.topic: conceptual
ms.date: 02/15/2019
ms.openlocfilehash: 35a056fbe01633dd93bd71ac2af16cba8a21344a
ms.sourcegitcommit: 2ce4f275bc45ef1fb061932634ac0cf04183f181
ms.translationtype: MT
ms.contentlocale: pt-PT
ms.lasthandoff: 05/07/2019
ms.locfileid: "65235726"
---
# <a name="data-transformation-expressions-in-mapping-data-flow"></a>Expressões de transformação de dados no fluxo de dados de mapeamento 

[!INCLUDE [notes](../../includes/data-factory-data-flow-preview.md)]

## <a name="expression-functions"></a>Funções de expressão

No Data Factory, utilize a linguagem de expressão da funcionalidade de mapeamento de fluxo de dados para configurar transformações de dados.

*********************************
### <code>abs</code>
<code><b>abs(<i>&lt;value1&gt;</i> : number) => number</b></code><br/><br/>
Módulo positivo do par de números.
* ``abs(-20) -> 20``
* ``abs(10) -> 10``
*********************************
### <code>acos</code>
<code><b>acos(<i>&lt;value1&gt;</i> : number) => double</b></code><br/><br/>
Calcula um valor de inversa consine * ``acos(1) -> 0.0``
*********************************
### <code>add</code>
<code><b>add(<i>&lt;value1&gt;</i> : any, <i>&lt;value2&gt;</i> : any) => any</b></code><br/><br/>
Adiciona um par de cadeias de caracteres ou números. Adiciona uma data para um número de dias. Acrescenta uma matriz do tipo semelhante para outro. Mesmo que o operador + * ``add(10, 20) -> 30``
* ``10 + 20 -> 30``
* ``add('ice', 'cream') -> 'icecream'``
* ``'ice' + 'cream' + ' cone' -> 'icecream cone'``
* ``add(toDate('2012-12-12'), 3) -> 2012-12-15 (date value)``
* ``toDate('2012-12-12') + 3 -> 2012-12-15 (date value)``
* ``[10, 20] + [30, 40] => [10, 20, 30, 40]``
*********************************
### <code>addDays</code>
<code><b>addDays(<i>&lt;date/timestamp&gt;</i> : datetime, <i>&lt;days to add&gt;</i> : integral) => datetime</b></code><br/><br/>
Adicione dias a uma data ou timestamp. Mesmo que o operador para data + * ``addDays(toDate('2016-08-08'), 1) -> 2016-08-09``
*********************************
### <code>addMonths</code>
<code><b>addMonths(<i>&lt;date/timestamp&gt;</i> : datetime, <i>&lt;months to add&gt;</i> : integral) => datetime</b></code><br/><br/>
Adicionar meses para uma data ou timestamp * ``addMonths(toDate('2016-08-31'), 1) -> 2016-09-30``
* ``addMonths(toTimestamp('2016-09-30 10:10:10'), -1) -> 2016-08-31 10:10:10``
*********************************
### <code>and</code>
<code><b>and(<i>&lt;value1&gt;</i> : boolean, <i>&lt;value2&gt;</i> : boolean) => boolean</b></code><br/><br/>
Operador lógico and. Mesmo que & & * ``and(true, false) -> false``
* ``true && false -> false``
*********************************
### <code>asin</code>
<code><b>asin(<i>&lt;value1&gt;</i> : number) => double</b></code><br/><br/>
Calcula um valor de seno inverso * ``asin(0) -> 0.0``
*********************************
### <code>atan</code>
<code><b>atan(<i>&lt;value1&gt;</i> : number) => double</b></code><br/><br/>
Calcula um valor de tangente inverso * ``atan(0) -> 0.0``
*********************************
### <code>atan2</code>
<code><b>atan2(<i>&lt;value1&gt;</i> : number, <i>&lt;value2&gt;</i> : number) => double</b></code><br/><br/>
Devolve o ângulo em radianos entre o eixo x positivo de um plano e o ponto de dado pelas coordenadas * ``atan2(0, 0) -> 0.0``
*********************************
### <code>avg</code>
<code><b>avg(<i>&lt;value1&gt;</i> : number) => number</b></code><br/><br/>
Obtém a média dos valores de uma coluna * ``avg(sales) -> 7523420.234``
*********************************
### <code>avgIf</code>
<code><b>avgIf(<i>&lt;value1&gt;</i> : boolean, <i>&lt;value2&gt;</i> : number) => number</b></code><br/><br/>
Com base num critérios obtém a média dos valores de uma coluna * ``avgIf(region == 'West', sales) -> 7523420.234``
*********************************
### <code>byName</code>
<code><b>byName(<i>&lt;column name&gt;</i> : string) => any</b></code><br/><br/>
Seleciona um valor de coluna pelo nome no fluxo. Se existirem várias correspondências, a primeira correspondência é devolvida. Se nenhuma correspondência, ele retorna um valor nulo. O valor retornado tem de ser o tipo convertido por uma das funções de conversão de tipo (TO_DATE, TO_STRING...).  Os nomes de coluna conhecidos no tempo de design devem ser resolvidos apenas pelo respetivo nome. Entradas calculadas não são suportadas mas pode utilizar substituições de parâmetro * ``toString(byName('parent')) -> appa``
* ``toLong(byName('income')) -> 9000000000009``
* ``toBoolean(byName('foster')) -> false``
* ``toLong(byName($debtCol)) -> 123456890``
* ``birthDate -> 12/31/2050``
* ``toString(byName('Bogus Column')) -> NULL``
*********************************
### <code>byPosition</code>
<code><b>byPosition(<i>&lt;position&gt;</i> : integer) => any</b></code><br/><br/>
Seleciona um valor de coluna por posição relativa (1 com base) no fluxo. Se a posição está fora dos limites, ele retorna um valor nulo. O valor retornado tem de ser o tipo convertido por uma das funções de conversão de tipo (TO_DATE, TO_STRING...) Entradas calculadas não são suportadas mas pode utilizar substituições de parâmetro * ``toString(byPosition(1)) -> amma``
* ``toDecimal(byPosition(2), 10, 2) -> 199990.99``
* ``toBoolean(byName(4)) -> false``
* ``toString(byName($colName)) -> family``
* ``toString(byPosition(1234)) -> NULL``
*********************************
### <code>case</code>
<code><b>case(<i>&lt;condition&gt;</i> : boolean, <i>&lt;true_expression&gt;</i> : any, <i>&lt;false_expression&gt;</i> : any, ...) => any</b></code><br/><br/>
Com base em condições de alternância, aplica-se um valor ou outro. Se o número de entradas é até mesmo, o outro é nulo para a última condição * ``case(custType == 'Premium', 10, 4.5)``
* ``case(custType == 'Premium', price*0.95, custType == 'Elite',   price*0.9, price*2)``
* ``case(dayOfWeek(saleDate) == 1, 'Sunday', dayOfWeek(saleDate) == 6, 'Saturday')``
*********************************
### <code>cbrt</code>
<code><b>cbrt(<i>&lt;value1&gt;</i> : number) => double</b></code><br/><br/>
Calcular a raiz do cubo de um número * ``cbrt(8) -> 2.0``
*********************************
### <code>ceil</code>
<code><b>ceil(<i>&lt;value1&gt;</i> : number) => number</b></code><br/><br/>
Devolve o menor número inteiro nem menor que o número * ``ceil(-0.1) -> 0``
*********************************
### <code>concat</code>
<code><b>concat(<i>&lt;this&gt;</i> : string, <i>&lt;that&gt;</i> : string, ...) => string</b></code><br/><br/>
Concatena um número variável de cadeias de caracteres em conjunto. Mesmo que o operador com cadeias de caracteres + * ``concat('Awesome', 'Cool', 'Product') -> 'AwesomeCoolProduct'``
* ``'Awesome' + 'Cool' + 'Product' -> 'AwesomeCoolProduct'``
* ``concat(addrLine1, ' ', addrLine2, ' ', city, ' ', state, ' ', zip)``
* ``addrLine1 + ' ' + addrLine2 + ' ' + city + ' ' + state + ' ' + zip``
*********************************
### <code>concatWS</code>
<code><b>concatWS(<i>&lt;separator&gt;</i> : string, <i>&lt;this&gt;</i> : string, <i>&lt;that&gt;</i> : string, ...) => string</b></code><br/><br/>
Concatena um número variável de cadeias de caracteres em conjunto com um separador. O primeiro parâmetro é o separador * ``concatWS(' ', 'Awesome', 'Cool', 'Product') -> 'Awesome Cool Product'``
* ``concatWS(' ' , addrLine1, addrLine2, city, state, zip) -> ``
* ``concatWS(',' , toString(order_total), toString(order_discount))``
*********************************
### <code>cos</code>
<code><b>cos(<i>&lt;value1&gt;</i> : number) => double</b></code><br/><br/>
Calcula um valor de cosseno * ``cos(10) -> -0.83907152907``
*********************************
### <code>cosh</code>
<code><b>cosh(<i>&lt;value1&gt;</i> : number) => double</b></code><br/><br/>
Calcula um co-seno hiperbólico de um valor * ``cosh(0) -> 1.0``
*********************************
### <code>count</code>
<code><b>count([<i>&lt;value1&gt;</i> : any]) => long</b></code><br/><br/>
Obtém a contagem agregada de valores. Se for especificada a coluna opcional (s), ele ignora valores NULL na contagem * ``count(custId) -> 100``
* ``count(custId, custName) -> 50``
* ``count() -> 125``
* ``count(iif(isNull(custId), 1, NULL)) -> 5``
*********************************
### <code>countDistinct</code>
<code><b>countDistinct(<i>&lt;value1&gt;</i> : any, [<i>&lt;value2&gt;</i> : any], ...) => long</b></code><br/><br/>
Obtém a contagem agregada de valores distintos de um conjunto de colunas * ``countDistinct(custId, custName) -> 60``
*********************************
### <code>countIf</code>
<code><b>countIf(<i>&lt;value1&gt;</i> : boolean, [<i>&lt;value2&gt;</i> : any]) => long</b></code><br/><br/>
Com base num obtém critérios a contagem agregada de valores. Se for especificada a coluna opcional, ele ignora valores NULL na contagem * ``countIf(state == 'CA' && commission < 10000, name) -> 100``
*********************************
### <code>covariancePopulation</code>
<code><b>covariancePopulation(<i>&lt;value1&gt;</i> : number, <i>&lt;value2&gt;</i> : number) => double</b></code><br/><br/>
Obtém a covariância de população entre duas colunas * ``covariancePopulation(sales, profit) -> 122.12``
*********************************
### <code>covariancePopulationIf</code>
<code><b>covariancePopulationIf(<i>&lt;value1&gt;</i> : boolean, <i>&lt;value2&gt;</i> : number, <i>&lt;value3&gt;</i> : number) => double</b></code><br/><br/>
Com base num critério, obtém a covariância de população de duas colunas * ``covariancePopulationIf(region == 'West', sales) -> 122.12``
*********************************
### <code>covarianceSample</code>
<code><b>covarianceSample(<i>&lt;value1&gt;</i> : number, <i>&lt;value2&gt;</i> : number) => double</b></code><br/><br/>
Obtém a covariância de exemplo de duas colunas * ``covarianceSample(sales, profit) -> 122.12``
*********************************
### <code>covarianceSampleIf</code>
<code><b>covarianceSampleIf(<i>&lt;value1&gt;</i> : boolean, <i>&lt;value2&gt;</i> : number, <i>&lt;value3&gt;</i> : number) => double</b></code><br/><br/>
Com base num critério, obtém a covariância de exemplo de duas colunas * ``covarianceSampleIf(region == 'West', sales, profit) -> 122.12``
*********************************
### <code>crc32</code>
<code><b>crc32(<i>&lt;value1&gt;</i> : any, ...) => long</b></code><br/><br/>
Calcula o hash de CRC32 do conjunto de colunas de diversos tipos de dados primitivos, tendo em conta um comprimento de bits que pode ser apenas de valores 0(256), 224, 256, 384, 512. Pode ser utilizado para calcular uma impressão digital para uma linha * ``crc32(256, 'gunchus', 8.2, 'bojjus', true, toDate('2010-4-4')) -> 3630253689``
*********************************
### <code>cumeDist</code>
<code><b>cumeDist() => integer</b></code><br/><br/>
A função de CumeDist calcula a posição de um valor em relação a todos os valores na partição. O resultado é o número de linhas anteriores ou iguais à linha atual na ordem da partição dividida pelo número total de linhas na partição de janela. Quaisquer valores de empate na ordem avaliará-se para a mesma posição.
* ``cumeDist() -> 1``
*********************************
### <code>currentDate</code>
<code><b>currentDate([<i>&lt;value1&gt;</i> : string]) => date</b></code><br/><br/>
Obtém a data atual quando esta tarefa começa a ser executada. Pode passar um fuso horário opcional na forma de 'GMT', "PST", "UTC", ' América/Caimão'. O fuso horário local é utilizado como predefinição.
* ``currentDate() -> 12-12-2030``
* ``currentDate('PST') -> 12-31-2050``
*********************************
### <code>currentTimestamp</code>
<code><b>currentTimestamp() => timestamp</b></code><br/><br/>
Obtém o timestamp atual quando a tarefa começa a ser executada com o fuso horário local * ``currentTimestamp() -> 12-12-2030T12:12:12``
*********************************
### <code>currentUTC</code>
<code><b>currentUTC([<i>&lt;value1&gt;</i> : string]) => timestamp</b></code><br/><br/>
Obtém o carimbo de hora a atual como UTC. Pode passar um fuso horário opcional na forma de 'GMT', "PST", "UTC", ' América/Caimão'. Padrão é obtido para o fuso horário atual * ``currentUTC() -> 12-12-2030T19:18:12``
* ``currentUTC('Asia/Seoul') -> 12-13-2030T11:18:12``
*********************************
### <code>dayOfMonth</code>
<code><b>dayOfMonth(<i>&lt;value1&gt;</i> : datetime) => integer</b></code><br/><br/>
Obtém o dia do mês com uma data * ``dayOfMonth(toDate('2018-06-08')) -> 08``
*********************************
### <code>dayOfWeek</code>
<code><b>dayOfWeek(<i>&lt;value1&gt;</i> : datetime) => integer</b></code><br/><br/>
Obtém o dia da semana com uma data. 1 - Domingo, 2 -... segunda-feira, 7 – Sábado * ``dayOfWeek(toDate('2018-06-08')) -> 7``
*********************************
### <code>dayOfYear</code>
<code><b>dayOfYear(<i>&lt;value1&gt;</i> : datetime) => integer</b></code><br/><br/>
Obtém o dia do ano com uma data * ``dayOfYear(toDate('2016-04-09')) -> 100``
*********************************
### <code>degrees</code>
<code><b>degrees(<i>&lt;value1&gt;</i> : number) => double</b></code><br/><br/>
Converte radianos em graus * ``degrees(3.141592653589793) -> 180``
*********************************
### <code>denseRank</code>
<code><b>denseRank(<i>&lt;value1&gt;</i> : any, ...) => integer</b></code><br/><br/>
Calcula a classificação de um valor de um grupo de valores. O resultado é um mais o número de linhas anteriores ou iguais à linha atual na ordem da partição. Os valores não produzirá lacunas na sequência. Classificação densa funciona até mesmo quando os dados não estão ordenados e procura por alteração nos valores * ``denseRank(salesQtr, salesAmt) -> 1``
*********************************
### <code>divide</code>
<code><b>divide(<i>&lt;value1&gt;</i> : any, <i>&lt;value2&gt;</i> : any) => any</b></code><br/><br/>
Divide o par de números. Mesmo que o / operador * ``divide(20, 10) -> 2``
* ``20 / 10 -> 2``
*********************************
### <code>endsWith</code>
<code><b>endsWith(<i>&lt;string&gt;</i> : string, <i>&lt;substring to check&gt;</i> : string) => boolean</b></code><br/><br/>
Verifica se a cadeia termina com a cadeia fornecida * ``endsWith('great', 'eat') -> true``
*********************************
### <code>equals</code>
<code><b>equals(<i>&lt;value1&gt;</i> : any, <i>&lt;value2&gt;</i> : any) => boolean</b></code><br/><br/>
Comparação de é igual a operador. Mesmo como = = operador * ``equals(12, 24) -> false``
* ``12==24 -> false``
* ``'bad'=='bad' -> true``
* ``'good'== NULL -> false``
* ``NULL===NULL -> false``
*********************************
### <code>equalsIgnoreCase</code>
<code><b>equalsIgnoreCase(<i>&lt;value1&gt;</i> : string, <i>&lt;value2&gt;</i> : string) => boolean</b></code><br/><br/>
Comparação de é igual a operador ignorando maiúsculas e minúsculas. Operador igual a <> = * ``'abc'<==>'abc' -> true``
* ``equalsIgnoreCase('abc', 'Abc') -> true``
*********************************
### <code>factorial</code>
<code><b>factorial(<i>&lt;value1&gt;</i> : number) => long</b></code><br/><br/>
Calcular o factorial de um número * ``factorial(5) -> 120``
*********************************
### <code>false</code>
<code><b>false() => boolean</b></code><br/><br/>
Sempre retorna um valor false. Utilize a função syntax(false()) se existir uma coluna chamada "falso" * ``isDiscounted == false()``
* ``isDiscounted() == false``
*********************************
### <code>first</code>
<code><b>first(<i>&lt;value1&gt;</i> : any, [<i>&lt;value2&gt;</i> : boolean]) => any</b></code><br/><br/>
Obtém o primeiro valor de um grupo de colunas. Se o segundo ignoreNulls de parâmetro for omitido, é assumido FALSO * ``first(sales) -> 12233.23``
* ``first(sales, false) -> NULL``
*********************************
### <code>floor</code>
<code><b>floor(<i>&lt;value1&gt;</i> : number) => number</b></code><br/><br/>
Devolve o maior número inteiro não superior ao número * ``floor(-0.1) -> -1``
*********************************
### <code>fromUTC</code>
<code><b>fromUTC(<i>&lt;value1&gt;</i> : timestamp, [<i>&lt;value2&gt;</i> : string]) => timestamp</b></code><br/><br/>
Converte o carimbo de hora da UTC. Pode, opcionalmente, transmitir o fuso horário na forma de 'GMT', "PST", "UTC", ' América/Caimão'. Padrão é obtido para o fuso horário atual * ``fromUTC(currentTimeStamp()) -> 12-12-2030T19:18:12``
* ``fromUTC(currentTimeStamp(), 'Asia/Seoul') -> 12-13-2030T11:18:12``
*********************************
### <code>greater</code>
<code><b>greater(<i>&lt;value1&gt;</i> : any, <i>&lt;value2&gt;</i> : any) => boolean</b></code><br/><br/>
Operador de comparação maior. Mesmo que > operador * ``greater(12, 24) -> false``
* ``'abcd' > 'abc' -> true``
*********************************
### <code>greaterOrEqual</code>
<code><b>greaterOrEqual(<i>&lt;value1&gt;</i> : any, <i>&lt;value2&gt;</i> : any) => boolean</b></code><br/><br/>
Comparação maior que ou o operador igual. Mesmo que > = operador * ``greaterOrEqual(12, 12) -> false``
* ``'abcd' >= 'abc' -> true``
*********************************
### <code>greatest</code>
<code><b>greatest(<i>&lt;value1&gt;</i> : any, ...) => any</b></code><br/><br/>
Devolve o maior valor entre a lista de valores como entrada. Devolve um valor nulo se todas as entradas são nulas * ``greatest(10, 30, 15, 20) -> 30``
* ``greatest(toDate('12/12/2010'), toDate('12/12/2011'), toDate('12/12/2000')) -> '12/12/2011'``
*********************************
### <code>hour</code>
<code><b>hour(<i>&lt;value1&gt;</i> : timestamp, [<i>&lt;value2&gt;</i> : string]) => integer</b></code><br/><br/>
Obtém o valor de hora de um carimbo. Pode passar um fuso horário opcional na forma de 'GMT', "PST", "UTC", ' América/Caimão'. O fuso horário local é utilizado como predefinição.
* ``hour(toTimestamp('2009-07-30T12:58:59')) -> 12``
* ``hour(toTimestamp('2009-07-30T12:58:59'), 'PST') -> 12``
*********************************
### <code>iif</code>
<code><b>iif(<i>&lt;condition&gt;</i> : boolean, <i>&lt;true_expression&gt;</i> : any, [<i>&lt;false_expression&gt;</i> : any]) => any</b></code><br/><br/>
Com base numa condição aplica-se um valor ou outro. Se o outro é não especificado é considerado NULL. Ambos os valores têm de ser compatíveis (numérica, cadeia de caracteres...) * ``iif(custType == 'Premium', 10, 4.5)``
* ``iif(amount > 100, 'High')``
* ``iif(dayOfWeek(saleDate) == 6, 'Weekend', 'Weekday')``
*********************************
### <code>in</code>
<code><b>in(<i>&lt;array of items&gt;</i> : array, <i>&lt;item to find&gt;</i> : any) => boolean</b></code><br/><br/>
Verifica se um item na matriz * ``in([10, 20, 30], 10) -> true``
* ``in(['good', 'kid'], 'bad') -> false``
*********************************
### <code>initCap</code>
<code><b>initCap(<i>&lt;value1&gt;</i> : string) => string</b></code><br/><br/>
Converte a primeira letra de cada palavra em maiúsculas. Palavras estão identificadas como separados por espaços em branco * ``initCap('cool iceCREAM') -> 'Cool IceCREAM'``
*********************************
### <code>instr</code>
<code><b>instr(<i>&lt;string&gt;</i> : string, <i>&lt;substring to find&gt;</i> : string) => integer</b></code><br/><br/>
Localiza a posição (1 com base) da subcadeia dentro de uma cadeia de caracteres. 0 é devolvido se não for encontrada * ``instr('great', 'eat') -> 3``
* ``instr('microsoft', 'o') -> 7``
* ``instr('good', 'bad') -> 0``
*********************************
### <code>isDelete</code>
<code><b>isDelete([<i>&lt;value1&gt;</i> : integer]) => boolean</b></code><br/><br/>
Verifica se a linha está marcada para eliminação. Para transformações a demorar mais do que um fluxo de entrada, pode passar o índice (baseado em 1) da transmissão em fluxo. Valor predefinido para o índice de fluxo é 1 * ``isDelete() -> true``
* ``isDelete(1) -> false``
*********************************
### <code>isError</code>
<code><b>isError([<i>&lt;value1&gt;</i> : integer]) => boolean</b></code><br/><br/>
Verifica se a linha é marcada como erro. Para transformações a demorar mais do que um fluxo de entrada, pode passar o índice (baseado em 1) da transmissão em fluxo. Valor predefinido para o índice de fluxo é 1 * ``isError() -> true``
* ``isError(1) -> false``
*********************************
### <code>isIgnore</code>
<code><b>isIgnore([<i>&lt;value1&gt;</i> : integer]) => boolean</b></code><br/><br/>
Verifica se a linha está marcada para ser ignorados. Para transformações a demorar mais do que um fluxo de entrada, pode passar o índice (baseado em 1) da transmissão em fluxo. Valor predefinido para o índice de fluxo é 1 * ``isIgnore() -> true``
* ``isIgnore(1) -> false``
*********************************
### <code>isInsert</code>
<code><b>isInsert([<i>&lt;value1&gt;</i> : integer]) => boolean</b></code><br/><br/>
Verifica se a linha está marcada para inserção. Para transformações a demorar mais do que um fluxo de entrada, pode passar o índice (baseado em 1) da transmissão em fluxo. Valor predefinido para o índice de fluxo é 1 * ``isInsert() -> true``
* ``isInsert(1) -> false``
*********************************
### <code>isMatch</code>
<code><b>isMatch([<i>&lt;value1&gt;</i> : integer]) => boolean</b></code><br/><br/>
Verifica se a linha é correspondida na pesquisa. Para transformações a demorar mais do que um fluxo de entrada, pode passar o índice (baseado em 1) da transmissão em fluxo. Valor predefinido para o índice de fluxo é 1 * ``isMatch() -> true``
* ``isMatch(1) -> false``
*********************************
### <code>isNull</code>
<code><b>isNull(<i>&lt;value1&gt;</i> : any) => boolean</b></code><br/><br/>
Verifica se o valor é nulo * ``isNull(NULL()) -> true``
* ``isNull('') -> false'``
*********************************
### <code>isUpdate</code>
<code><b>isUpdate([<i>&lt;value1&gt;</i> : integer]) => boolean</b></code><br/><br/>
Verifica se a linha está marcada para atualização. Para transformações a demorar mais do que um fluxo de entrada, pode passar o índice (baseado em 1) da transmissão em fluxo. Valor predefinido para o índice de fluxo é 1 * ``isUpdate() -> true``
* ``isUpdate(1) -> false``
*********************************
### <code>kurtosis</code>
<code><b>kurtosis(<i>&lt;value1&gt;</i> : number) => double</b></code><br/><br/>
Obtém o kurtosis de uma coluna * ``kurtosis(sales) -> 122.12``
*********************************
### <code>kurtosisIf</code>
<code><b>kurtosisIf(<i>&lt;value1&gt;</i> : boolean, <i>&lt;value2&gt;</i> : number) => double</b></code><br/><br/>
Com base num critério, obtém o kurtosis de uma coluna * ``kurtosisIf(region == 'West', sales) -> 122.12``
*********************************
### <code>lag</code>
<code><b>lag(<i>&lt;value&gt;</i> : any, [<i>&lt;number of rows to look before&gt;</i> : number], [<i>&lt;default value&gt;</i> : any]) => any</b></code><br/><br/>
Obtém o valor das primeiras linhas de n parâmetro avaliado antes da linha atual. O segundo parâmetro é o número de linhas para procurar novamente e o valor predefinido é 1. Se não existirem como número de linhas é devolvido um valor nulo, a menos que é especificado um valor predefinido * ``lag(amount, 2) -> 60``
* ``lag(amount, 2000, 100) -> 100``
*********************************
### <code>last</code>
<code><b>last(<i>&lt;value1&gt;</i> : any, [<i>&lt;value2&gt;</i> : boolean]) => any</b></code><br/><br/>
Obtém o último valor de um grupo de colunas. Se o segundo ignoreNulls de parâmetro for omitido, é assumido FALSO * ``last(sales) -> 523.12``
* ``last(sales, false) -> NULL``
*********************************
### <code>lastDayOfMonth</code>
<code><b>lastDayOfMonth(<i>&lt;value1&gt;</i> : datetime) => date</b></code><br/><br/>
Obtém a data do último do mês com uma data * ``lastDayOfMonth(toDate('2009-01-12')) -> 2009-01-31``
*********************************
### <code>lead</code>
<code><b>lead(<i>&lt;value&gt;</i> : any, [<i>&lt;number of rows to look after&gt;</i> : number], [<i>&lt;default value&gt;</i> : any]) => any</b></code><br/><br/>
Obtém o valor das primeiras linhas de n parâmetro avaliada após a linha atual. O segundo parâmetro é o número de linhas a olhar em frente e o valor predefinido é 1. Se não existirem como número de linhas é devolvido um valor nulo, a menos que é especificado um valor predefinido * ``lead(amount, 2) -> 60``
* ``lead(amount, 2000, 100) -> 100``
*********************************
### <code>least</code>
<code><b>least(<i>&lt;value1&gt;</i> : any, ...) => any</b></code><br/><br/>
Comparação menor ou igual operador. Mesmo que < = operador * ``least(10, 30, 15, 20) -> 10``
* ``least(toDate('12/12/2010'), toDate('12/12/2011'), toDate('12/12/2000')) -> '12/12/2000'``
*********************************
### <code>left</code>
<code><b>left(<i>&lt;string to subset&gt;</i> : string, <i>&lt;number of characters&gt;</i> : integral) => string</b></code><br/><br/>
Extrai um início de subcadeia no índice 1 com o número de carateres. Igual a SUBCADEIA (str, 1, n) * ``left('bojjus', 2) -> 'bo'``
* ``left('bojjus', 20) -> 'bojjus'``
*********************************
### <code>length</code>
<code><b>length(<i>&lt;value1&gt;</i> : string) => integer</b></code><br/><br/>
Devolve o comprimento da cadeia de caracteres * ``length('kiddo') -> 5``
*********************************
### <code>lesser</code>
<code><b>lesser(<i>&lt;value1&gt;</i> : any, <i>&lt;value2&gt;</i> : any) => boolean</b></code><br/><br/>
Comparação menos operador. Mesmo que < operador * ``lesser(12 < 24) -> true``
* ``'abcd' < 'abc' -> false``
*********************************
### <code>lesserOrEqual</code>
<code><b>lesserOrEqual(<i>&lt;value1&gt;</i> : any, <i>&lt;value2&gt;</i> : any) => boolean</b></code><br/><br/>
Comparação menor ou igual operador. Mesmo que < = operador * ``lesserOrEqual(12, 12) -> true``
* ``'abcd' <= 'abc' -> false``
*********************************
### <code>levenshtein</code>
<code><b>levenshtein(<i>&lt;from string&gt;</i> : string, <i>&lt;to string&gt;</i> : string) => integer</b></code><br/><br/>
Obtém a distância de levenshtein entre duas cadeias de caracteres * ``levenshtein('boys', 'girls') -> 4``
*********************************
### <code>like</code>
<code><b>like(<i>&lt;string&gt;</i> : string, <i>&lt;pattern match&gt;</i> : string) => boolean</b></code><br/><br/>
O padrão é uma cadeia que é correspondida literalmente. As exceções são os seguintes símbolos especiais: _ corresponde a qualquer caráter a entrada (similar. numa expressão regular posix) % corresponde a zero ou mais carateres na entrada (semelhante a. * numa expressão regular posix).
O caráter de escape é '. Se um caráter de escape precede um símbolo especial ou de outro caráter escape, o seguinte caráter é correspondido literalmente. É inválido para qualquer outro caractere de escape.
* ``like('icecream', 'ice%') -> true``
*********************************
### <code>locate</code>
<code><b>locate(<i>&lt;substring to find&gt;</i> : string, <i>&lt;string&gt;</i> : string, [<i>&lt;from index - 1-based&gt;</i> : integral]) => integer</b></code><br/><br/>
Localiza a posição (1 com base) da subcadeia dentro de uma cadeia de caracteres a partir de uma determinada posição. Se a posição for omitida, ele é considerado desde o início da cadeia de caracteres. 0 é devolvido se não for encontrada * ``locate('eat', 'great') -> 3``
* ``locate('o', 'microsoft', 6) -> 7``
* ``locate('bad', 'good') -> 0``
*********************************
### <code>log</code>
<code><b>log(<i>&lt;value1&gt;</i> : number, [<i>&lt;value2&gt;</i> : number]) => double</b></code><br/><br/>
Calcula o valor de registo. Uma base opcional pode ser resto fornecido um número de euler se utilizado * ``log(100, 10) -> 2``
*********************************
### <code>log10</code>
<code><b>log10(<i>&lt;value1&gt;</i> : number) => double</b></code><br/><br/>
Calcula o valor de registo com base na base de 10 * ``log10(100) -> 2``
*********************************
### <code>lower</code>
<code><b>lower(<i>&lt;value1&gt;</i> : string) => string</b></code><br/><br/>
Lowercases uma cadeia de caracteres * ``lower('GunChus') -> 'gunchus'``
*********************************
### <code>lpad</code>
<code><b>lpad(<i>&lt;string to pad&gt;</i> : string, <i>&lt;final padded length&gt;</i> : integral, <i>&lt;padding&gt;</i> : string) => string</b></code><br/><br/>
Esquerda preenche a cadeia de caracteres, acrescentando fornecido até que seja de uma determinada extensão. Se a cadeia de caracteres é igual ou superior ao comprimento, em seguida, ele é considerado não operacional * ``lpad('great', 10, '-') -> '-----great'`` 
* ``lpad('great', 4, '-') -> 'great'`` 
* ' lpad (8 'excelente,', ' <> ") ->" <><great'``
*********************************
### <code>ltrim</code>
<code><b>ltrim(<i>&lt;string to trim&gt;</i> : string, <i>&lt;trim characters&gt;</i> : string) => string</b></code><br/><br/>
Esquerda corta uma cadeia de caracteres à esquerda. Se o segundo parâmetro é não especificado,-corta espaços em branco. Caso contrário ele corta qualquer caráter especificado no segundo parâmetro * ``ltrim('!--!wor!ld!', '-!') -> 'wor!ld!'``
*********************************
### <code>max</code>
<code><b>max(<i>&lt;value1&gt;</i> : any) => any</b></code><br/><br/>
Obtém o valor máximo de uma coluna * ``MAX(sales) -> 12312131.12``
*********************************
### <code>maxIf</code>
<code><b>maxIf(<i>&lt;value1&gt;</i> : boolean, <i>&lt;value2&gt;</i> : any) => any</b></code><br/><br/>
Com base num critério, obtém o valor máximo de uma coluna * ``maxIf(region == 'West', sales) -> 99999.56``
*********************************
### <code>md5</code>
<code><b>md5(<i>&lt;value1&gt;</i> : any, ...) => string</b></code><br/><br/>
Calcula o resumo de MD5 de conjunto de colunas de diversos tipos de dados primitivos e devolve uma cadeia hexadecimal de 32 carateres. Pode ser utilizado para calcular uma impressão digital para uma linha * ``md5(5, 'gunchus', 8.2, 'bojjus', true, toDate('2010-4-4')) -> 'c1527622a922c83665e49835e46350fe'``
*********************************
### <code>mean</code>
<code><b>mean(<i>&lt;value1&gt;</i> : number) => number</b></code><br/><br/>
Obtém a média dos valores de uma coluna. Mesmo que a média * ``mean(sales) -> 7523420.234``
*********************************
### <code>meanIf</code>
<code><b>meanIf(<i>&lt;value1&gt;</i> : boolean, <i>&lt;value2&gt;</i> : number) => number</b></code><br/><br/>
Com base num critérios obtém a média dos valores de uma coluna. Mesmo que avgIf * ``meanIf(region == 'West', sales) -> 7523420.234``
*********************************
### <code>min</code>
<code><b>min(<i>&lt;value1&gt;</i> : any) => any</b></code><br/><br/>
Obtém o valor mínimo de uma coluna * ``min(sales) -> 00.01``
* ``min(orderDate) -> 12/12/2000``
*********************************
### <code>minIf</code>
<code><b>minIf(<i>&lt;value1&gt;</i> : boolean, <i>&lt;value2&gt;</i> : any) => any</b></code><br/><br/>
Com base num critério, obtém o valor mínimo de uma coluna * ``minIf(region == 'West', sales) -> 00.01``
*********************************
### <code>minus</code>
<code><b>minus(<i>&lt;value1&gt;</i> : any, <i>&lt;value2&gt;</i> : any) => any</b></code><br/><br/>
Subtrai esses números. Subtrai a partir de um data, número de dias. Mesmo que-operador * ``minus(20, 10) -> 10``
* ``20 - 10 -> 10``
* ``minus(toDate('2012-12-15'), 3) -> 2012-12-12 (date value)``
* ``toDate('2012-12-15') - 3 -> 2012-12-13 (date value)``
*********************************
### <code>minute</code>
<code><b>minute(<i>&lt;value1&gt;</i> : timestamp, [<i>&lt;value2&gt;</i> : string]) => integer</b></code><br/><br/>
Obtém o valor de minuto de um carimbo. Pode passar um fuso horário opcional na forma de 'GMT', "PST", "UTC", ' América/Caimão'. O fuso horário local é utilizado como predefinição.
* ``minute(toTimestamp('2009-07-30T12:58:59')) -> 58``
* ``minute(toTimestamp('2009-07-30T12:58:59', 'PST')) -> 58``
*********************************
### <code>mod</code>
<code><b>mod(<i>&lt;value1&gt;</i> : any, <i>&lt;value2&gt;</i> : any) => any</b></code><br/><br/>
Módulo do par de números. Mesmo que o operador % * ``mod(20, 8) -> 4``
* ``20 % 8 -> 4``
*********************************
### <code>month</code>
<code><b>month(<i>&lt;value1&gt;</i> : datetime) => integer</b></code><br/><br/>
Obtém o valor do mês de uma data ou timestamp * ``month(toDate('2012-8-8')) -> 8``
*********************************
### <code>monthsBetween</code>
<code><b>monthsBetween(<i>&lt;from date/timestamp&gt;</i> : datetime, <i>&lt;to date/timestamp&gt;</i> : datetime, [<i>&lt;time zone&gt;</i> : boolean], [<i>&lt;value4&gt;</i> : string]) => double</b></code><br/><br/>
Obtém o número de meses entre dois datesYou pode passar um fuso horário opcional na forma de 'GMT', "PST", "UTC", ' América/Caimão'. O fuso horário local é utilizado como predefinição.
* ``monthsBetween(toDate('1997-02-28 10:30:00'), toDate('1996-10-30')) -> 3.94959677``
*********************************
### <code>multiply</code>
<code><b>multiply(<i>&lt;value1&gt;</i> : any, <i>&lt;value2&gt;</i> : any) => any</b></code><br/><br/>
Multiplica o par de números. Mesmo que o * operador * ``multiply(20, 10) -> 200``
* ``20 * 10 -> 200``
*********************************
### <code>nTile</code>
<code><b>nTile([<i>&lt;value1&gt;</i> : integer]) => integer</b></code><br/><br/>
A função NTile divide as linhas para cada partição de janela em `n` registos que vão de 1 para, no máximo `n`. Valores de registo diferem no máximo 1. Se o número de linhas na partição não dividir uniformemente no número de buckets, em seguida, os valores do restante são um distribuída por bucket, começando com o primeiro registo. A função NTile é útil para o cálculo de tertiles, quartiles, deciles e outras estatísticas de resumidas comuns. A função calcula duas variáveis durante a inicialização: O tamanho de um registo regular terão uma linha extra adicionada a ele. Ambas as variáveis baseiam-se no tamanho da partição atual. Durante o processo de cálculo a função mantém um registo do número da linha atual, o número de registo atual e o número de linha em que o bucket será alterado (bucketThreshold). Quando a atingir de número de linha atual registo limiar, o valor de registo é aumentado em um e o limiar é aumentado no tamanho do registo (mais uma adicionais se o registo atual é preenchido).
* ``nTile() -> 1``
* ``nTile(numOfBuckets) -> 1``
*********************************
### <code>negate</code>
<code><b>negate(<i>&lt;value1&gt;</i> : number) => number</b></code><br/><br/>
Elimina um número. Transforma números positivos para negativo e vice versa * ``negate(13) -> -13``
*********************************
### <code>nextSequence</code>
<code><b>nextSequence() => long</b></code><br/><br/>
Devolve a seguinte sequência exclusiva. O número é consecutivos apenas dentro de uma partição e tem como prefixo o partitionId * ``nextSequence() -> 12313112``
*********************************
### <code>normalize</code>
<code><b>normalize(<i>&lt;String to normalize&gt;</i> : string) => string</b></code><br/><br/>
Normalizar o valor de cadeia de caracteres para separar os caracteres acentuados unicode * ``normalize('boys') -> 'boys'``
*********************************
### <code>not</code>
<code><b>not(<i>&lt;value1&gt;</i> : boolean) => boolean</b></code><br/><br/>
Operador de negação lógica * ``not(true) -> false``
* ``not(premium)``
*********************************
### <code>notEquals</code>
<code><b>notEquals(<i>&lt;value1&gt;</i> : any, <i>&lt;value2&gt;</i> : any) => boolean</b></code><br/><br/>
Comparação não é igual a operador. Mesmo que! = operador * ``12!=24 -> true``
* ``'abc'!='abc' -> false``
*********************************
### <code>null</code>
<code><b>null() => null</b></code><br/><br/>
Devolve um valor nulo. Utilize a função syntax(null()) se existir uma coluna chamada 'null'. Qualquer operação que utiliza irá resultar num valor nulo * ``custId = NULL (for derived field)``
* ``custId == NULL -> NULL``
* ``'nothing' + NULL -> NULL``
* ``10 * NULL -> NULL'``
* ``NULL == '' -> NULL'``
*********************************
### <code>or</code>
<code><b>or(<i>&lt;value1&gt;</i> : boolean, <i>&lt;value2&gt;</i> : boolean) => boolean</b></code><br/><br/>
Operador ou lógico. Mesmo que | | * ``or(true, false) -> true``
* ``true || false -> true``
*********************************
### <code>pMod</code>
<code><b>pMod(<i>&lt;value1&gt;</i> : any, <i>&lt;value2&gt;</i> : any) => any</b></code><br/><br/>
Módulo positivo do par de números.
* ``pmod(-20, 8) -> 4``
*********************************
### <code>power</code>
<code><b>power(<i>&lt;value1&gt;</i> : number, <i>&lt;value2&gt;</i> : number) => double</b></code><br/><br/>
Eleva um número à potência de outro * ``power(10, 2) -> 100``
*********************************
### <code>rank</code>
<code><b>rank(<i>&lt;value1&gt;</i> : any, ...) => integer</b></code><br/><br/>
Calcula a classificação de um valor de um grupo de valores. O resultado é um mais o número de linhas anteriores ou iguais à linha atual na ordem da partição. Os valores produzirá lacunas na sequência. Classificação funciona até mesmo quando dados não estão ordenados e procura por alteração nos valores * ``rank(salesQtr, salesAmt) -> 1``
*********************************
### <code>regexExtract</code>
<code><b>regexExtract(<i>&lt;string&gt;</i> : string, <i>&lt;regex to find&gt;</i> : string, [<i>&lt;match group 1-based index&gt;</i> : integral]) => string</b></code><br/><br/>
Extrair uma subcadeia correspondente para um padrão regex fornecido. O último parâmetro identifica o grupo de correspondência e é predefinido como 1, se for omitido. Utilize "<regex>'(back quote) para corresponder a uma cadeia de caracteres sem carateres de escape * ``regexExtract('Cost is between 600 and 800 dollars', '(\\d+) and (\\d+)', 2) -> '800'``
* ``regexExtract('Cost is between 600 and 800 dollars', `(\d+) and (\d+)`, 2) -> '800'``
*********************************
### <code>regexMatch</code>
<code><b>regexMatch(<i>&lt;string&gt;</i> : string, <i>&lt;regex to match&gt;</i> : string) => boolean</b></code><br/><br/>
Verifica se a cadeia de caracteres corresponde ao padrão regex fornecido. Utilize "<regex>'(back quote) para corresponder a uma cadeia de caracteres sem carateres de escape * ``regexMatch('200.50', '(\\d+).(\\d+)') -> true``
* ``regexMatch('200.50', `(\d+).(\d+)`) -> true``
*********************************
### <code>regexReplace</code>
<code><b>regexReplace(<i>&lt;string&gt;</i> : string, <i>&lt;regex to find&gt;</i> : string, <i>&lt;substring to replace&gt;</i> : string) => string</b></code><br/><br/>
Substitua todas as ocorrências de um padrão regex por outra subcadeia na cadeia de caracteres determinada utilização '<regex>'(back quote) para corresponder a uma cadeia de caracteres sem carateres de escape * ``regexReplace('100 and 200', '(\\d+)', 'bojjus') -> 'bojjus and bojjus'``
* ``regexReplace('100 and 200', `(\d+)`, 'gunchus') -> 'gunchus and gunchus'``
*********************************
### <code>regexSplit</code>
<code><b>regexSplit(<i>&lt;string to split&gt;</i> : string, <i>&lt;regex expression&gt;</i> : string) => array</b></code><br/><br/>
Divide uma cadeia de caracteres com base num delimitador com base na regex e retorna uma matriz de cadeias de caracteres * ``regexSplit('oneAtwoBthreeC', '[CAB]') -> ['one', 'two', 'three']``
* ``regexSplit('oneAtwoBthreeC', '[CAB]')[1] -> 'one'``
* ``regexSplit('oneAtwoBthreeC', '[CAB]')[0] -> NULL``
* ``regexSplit('oneAtwoBthreeC', '[CAB]')[20] -> NULL``
*********************************
### <code>replace</code>
<code><b>replace(<i>&lt;string&gt;</i> : string, <i>&lt;substring to find&gt;</i> : string, <i>&lt;substring to replace&gt;</i> : string) => string</b></code><br/><br/>
Substitua todas as ocorrências de uma subcadeia por outra subcadeia em determinada seqüência de caracteres * ``replace('doggie dog', 'dog', 'cat') -> 'catgie cat'``
* ``replace('doggie dog', 'dog', '') -> 'gie'``
*********************************
### <code>reverse</code>
<code><b>reverse(<i>&lt;value1&gt;</i> : string) => string</b></code><br/><br/>
Reverte uma cadeia de caracteres * ``reverse('gunchus') -> 'suhcnug'``
*********************************
### <code>right</code>
<code><b>right(<i>&lt;string to subset&gt;</i> : string, <i>&lt;number of characters&gt;</i> : integral) => string</b></code><br/><br/>
Extrai uma subcadeia com o número de carateres da direita. Mesmo que a SUBCADEIA (str, LENGTH(str) - n, n) * ``right('bojjus', 2) -> 'us'``
* ``right('bojjus', 20) -> 'bojjus'``
*********************************
### <code>rlike</code>
<code><b>rlike(<i>&lt;string&gt;</i> : string, <i>&lt;pattern match&gt;</i> : string) => boolean</b></code><br/><br/>
Verifica se a cadeia de caracteres corresponde ao padrão regex determinado * ``rlike('200.50', '(\d+).(\d+)') -> true``
*********************************
### <code>round</code>
<code><b>round(<i>&lt;number&gt;</i> : number, [<i>&lt;scale to round&gt;</i> : number], [<i>&lt;rounding option&gt;</i> : integral]) => double</b></code><br/><br/>
Arredonda um número com um dimensionamento opcional e um modo de arredondamento opcional. Se a escala for omitida, ele padrão é obtido como 0.  Se o modo for omitido, ele padrão é obtido para ROUND_HALF_UP(5). Os valores para o arredondamento de incluem 1 - ROUND_UP 2 - ROUND_DOWN 3 - ROUND_CEILING 4 - ROUND_FLOOR 5 - ROUND_HALF_UP 6 - ROUND_HALF_DOWN 7 - ROUND_HALF_EVEN 8 - ROUND_UNNECESSARY * ``round(100.123) -> 100.0``
* ``round(2.5, 0) -> 3.0``
* ``round(5.3999999999999995, 2, 7) -> 5.40``
*********************************
### <code>rowNumber</code>
<code><b>rowNumber() => integer</b></code><br/><br/>
Atribui uma linha seqüencial linhas numa janela a partir de 1 de numeração * ``rowNumber() -> 1``
*********************************
### <code>rpad</code>
<code><b>rpad(<i>&lt;string to pad&gt;</i> : string, <i>&lt;final padded length&gt;</i> : integral, <i>&lt;padding&gt;</i> : string) => string</b></code><br/><br/>
Direita preenche a cadeia de caracteres, acrescentando fornecido até que seja de uma determinada extensão. Se a cadeia de caracteres é igual ou superior ao comprimento, em seguida, ele é considerado não operacional * ``rpad('great', 10, '-') -> 'great-----'`` 
* ``rpad('great', 4, '-') -> 'great'`` 
* ``rpad('great', 8, '<>') -> 'great<><'`` 
*********************************
### <code>rtrim</code>rtrim</code>
<code><b>rtrim(<i>&lt;string to trim&gt;</i> : string, <i>&lt;trim characters&gt;</i> : string) => string</b></code><br/><br/>
Direita corta uma cadeia de caracteres à esquerda. Se o segundo parâmetro é não especificado,-corta espaços em branco. Caso contrário ele corta qualquer caráter especificado no segundo parâmetro * ``rtrim('!--!wor!ld!', '-!') -> '!--!wor!ld'``
*********************************
### <code>second</code>
<code><b>second(<i>&lt;value1&gt;</i> : timestamp, [<i>&lt;value2&gt;</i> : string]) => integer</b></code><br/><br/>
Obtém o segundo valor de uma data. Pode passar um fuso horário opcional na forma de 'GMT', "PST", "UTC", ' América/Caimão'. O fuso horário local é utilizado como predefinição.
* ``second(toTimestamp('2009-07-30T12:58:59')) -> 59``
*********************************
### <code>sha1</code>
<code><b>sha1(<i>&lt;value1&gt;</i> : any, ...) => string</b></code><br/><br/>
Calcula o resumo de SHA-1 do conjunto de colunas de diversos tipos de dados primitivos e devolve uma cadeia hexadecimal de 40 carateres. Pode ser utilizado para calcular uma impressão digital para uma linha * ``sha1(5, 'gunchus', 8.2, 'bojjus', true, toDate('2010-4-4')) -> '63849fd2abb65fbc626c60b1f827bd05573f0cea'``
*********************************
### <code>sha2</code>
<code><b>sha2(<i>&lt;value1&gt;</i> : integer, <i>&lt;value2&gt;</i> : any, ...) => string</b></code><br/><br/>
Calcula o resumo de SHA-2 de conjunto de colunas de diversos tipos de dados primitivos, tendo em conta um comprimento de bits que pode ser apenas de valores 0(256), 224, 256, 384, 512. Pode ser utilizado para calcular uma impressão digital para uma linha * ``sha2(256, 'gunchus', 8.2, 'bojjus', true, toDate('2010-4-4')) -> 'd3b2bff62c3a00e9370b1ac85e428e661a7df73959fa1a96ae136599e9ee20fd'``
*********************************
### <code>sin</code>
<code><b>sin(<i>&lt;value1&gt;</i> : number) => double</b></code><br/><br/>
Calcula um valor de seno * ``sin(2) -> 0.90929742682``
*********************************
### <code>sinh</code>
<code><b>sinh(<i>&lt;value1&gt;</i> : number) => double</b></code><br/><br/>
Calcula um valor de seno hiperbólico * ``sinh(0) -> 0.0``
*********************************
### <code>skewness</code>
<code><b>skewness(<i>&lt;value1&gt;</i> : number) => double</b></code><br/><br/>
Obtém a assimetrias de uma coluna * ``skewness(sales) -> 122.12``
*********************************
### <code>skewnessIf</code>
<code><b>skewnessIf(<i>&lt;value1&gt;</i> : boolean, <i>&lt;value2&gt;</i> : number) => double</b></code><br/><br/>
Com base num critério, obtém a assimetrias de uma coluna * ``skewnessIf(region == 'West', sales) -> 122.12``
*********************************
### <code>slice</code>
<code><b>slice(<i>&lt;array to slice&gt;</i> : array, <i>&lt;from 1-based index&gt;</i> : integral, [<i>&lt;number of items&gt;</i> : integral]) => array</b></code><br/><br/>
Extrai um subconjunto de uma matriz de uma posição. Posição é 1, com base. Se o comprimento for omitido, ele padrão é obtido ao fim da cadeia * ``slice([10, 20, 30, 40], 1, 2) -> [10, 20]``
* ``slice([10, 20, 30, 40], 2) -> [20, 30, 40]``
* ``slice([10, 20, 30, 40], 2)[1] -> 20``
* ``slice([10, 20, 30, 40], 2)[0] -> NULL``
* ``slice([10, 20, 30, 40], 2)[20] -> NULL``
* ``slice([10, 20, 30, 40], 8) -> []``
*********************************
### <code>soundex</code>
<code><b>soundex(<i>&lt;value1&gt;</i> : string) => string</b></code><br/><br/>
Obtém o código de soundex para a cadeia de caracteres * ``soundex('genius') -> 'G520'``
*********************************
### <code>split</code>
<code><b>split(<i>&lt;string to split&gt;</i> : string, <i>&lt;split characters&gt;</i> : string) => array</b></code><br/><br/>
Divide uma cadeia de caracteres com base num delimitador e retorna uma matriz de cadeias de caracteres * ``split('100,200,300', ',') -> ['100', '200', '300']``
* ``split('100,200,300', '|') -> ['100,200,300']``
* ``split('100, 200, 300', ', ') -> ['100', '200', '300']``
* ``split('100, 200, 300', ', ')[1] -> '100'``
* ``split('100, 200, 300', ', ')[0] -> NULL``
* ``split('100, 200, 300', ', ')[20] -> NULL``
* ``split('100200300', ',') -> ['100200300']``
*********************************
### <code>sqrt</code>
<code><b>sqrt(<i>&lt;value1&gt;</i> : number) => double</b></code><br/><br/>
Calcula a raiz quadrada de um número * ``sqrt(9) -> 3``
*********************************
### <code>startsWith</code>
<code><b>startsWith(<i>&lt;string&gt;</i> : string, <i>&lt;substring to check&gt;</i> : string) => boolean</b></code><br/><br/>
Verifica se a cadeia começa com a cadeia fornecida * ``startsWith('great', 'gr') -> true``
*********************************
### <code>stddev</code>
<code><b>stddev(<i>&lt;value1&gt;</i> : number) => double</b></code><br/><br/>
Obtém o desvio-padrão de uma coluna * ``stdDev(sales) -> 122.12``
*********************************
### <code>stddevIf</code>
<code><b>stddevIf(<i>&lt;value1&gt;</i> : boolean, <i>&lt;value2&gt;</i> : number) => double</b></code><br/><br/>
Com base num critério, obtém o desvio-padrão de uma coluna * ``stddevIf(region == 'West', sales) -> 122.12``
*********************************
### <code>stddevPopulation</code>
<code><b>stddevPopulation(<i>&lt;value1&gt;</i> : number) => double</b></code><br/><br/>
Obtém o desvio-padrão da população de uma coluna * ``stddevPopulation(sales) -> 122.12``
*********************************
### <code>stddevPopulationIf</code>
<code><b>stddevPopulationIf(<i>&lt;value1&gt;</i> : boolean, <i>&lt;value2&gt;</i> : number) => double</b></code><br/><br/>
Com base num critério, obtém o desvio-padrão da população de uma coluna * ``stddevPopulationIf(region == 'West', sales) -> 122.12``
*********************************
### <code>stddevSample</code>
<code><b>stddevSample(<i>&lt;value1&gt;</i> : number) => double</b></code><br/><br/>
Obtém o desvio-padrão de exemplo de uma coluna * ``stddevSample(sales) -> 122.12``
*********************************
### <code>stddevSampleIf</code>
<code><b>stddevSampleIf(<i>&lt;value1&gt;</i> : boolean, <i>&lt;value2&gt;</i> : number) => double</b></code><br/><br/>
Com base num critério, obtém o desvio-padrão de exemplo de uma coluna * ``stddevSampleIf(region == 'West', sales) -> 122.12``
*********************************
### <code>subDays</code>
<code><b>subDays(<i>&lt;date/timestamp&gt;</i> : datetime, <i>&lt;days to subtract&gt;</i> : integral) => datetime</b></code><br/><br/>
Subtrai meses a partir de uma data. Mesmo que-operador para data * ``subDays(toDate('2016-08-08'), 1) -> 2016-08-09``
*********************************
### <code>subMonths</code>
<code><b>subMonths(<i>&lt;date/timestamp&gt;</i> : datetime, <i>&lt;months to subtract&gt;</i> : integral) => datetime</b></code><br/><br/>
Subtrair meses a partir de uma data ou timestamp * ``subMonths(toDate('2016-09-30'), 1) -> 2016-08-31``
*********************************
### <code>substring</code>
<code><b>substring(<i>&lt;string to subset&gt;</i> : string, <i>&lt;from 1-based index&gt;</i> : integral, [<i>&lt;number of characters&gt;</i> : integral]) => string</b></code><br/><br/>
Extrai uma subseqüência de uma determinada extensão de uma posição. Posição é 1, com base. Se o comprimento for omitido, ele padrão é obtido ao fim da cadeia * ``substring('Cat in the hat', 5, 2) -> 'in'``
* ``substring('Cat in the hat', 5, 100) -> 'in the hat'``
* ``substring('Cat in the hat', 5) -> 'in the hat'``
* ``substring('Cat in the hat', 100, 100) -> ''``
*********************************
### <code>sum</code>
<code><b>sum(<i>&lt;value1&gt;</i> : number) => number</b></code><br/><br/>
Obtém a soma de agregação de uma coluna numérica * ``sum(col) -> value``
*********************************
### <code>sumDistinct</code>
<code><b>sumDistinct(<i>&lt;value1&gt;</i> : number) => number</b></code><br/><br/>
Obtém a soma de agregação de valores distintos de uma coluna numérica * ``sumDistinct(col) -> value``
*********************************
### <code>sumDistinctIf</code>
<code><b>sumDistinctIf(<i>&lt;value1&gt;</i> : boolean, <i>&lt;value2&gt;</i> : number) => number</b></code><br/><br/>
Com base em critérios obtém a soma de agregação de uma coluna numérica. A condição pode ser baseada em qualquer coluna * ``sumDistinctIf(state == 'CA' && commission < 10000, sales) -> value``
* ``sumDistinctIf(true, sales) -> SUM(sales) ``
*********************************
### <code>sumIf</code>
<code><b>sumIf(<i>&lt;value1&gt;</i> : boolean, <i>&lt;value2&gt;</i> : number) => number</b></code><br/><br/>
Com base em critérios obtém a soma de agregação de uma coluna numérica. A condição pode ser baseada em qualquer coluna * ``sumIf(state == 'CA' && commission < 10000, sales) -> value``
* ``sumIf(true, sales) -> SUM(sales) ``
*********************************
### <code>tan</code>
<code><b>tan(<i>&lt;value1&gt;</i> : number) => double</b></code><br/><br/>
Calcula um valor de tangente * ``tan(0) -> 0.0``
*********************************
### <code>tanh</code>
<code><b>tanh(<i>&lt;value1&gt;</i> : number) => double</b></code><br/><br/>
Calcula um valor de tangente hiperbólico * ``tanh(0) -> 0.0``
*********************************
### <code>toBoolean</code>
<code><b>toBoolean(<i>&lt;value1&gt;</i> : string) => boolean</b></code><br/><br/>
Converte um valor de (t' ', 'true', 'y', 'Sim', '1') como true e ("f", "falso", ' n ', 'não', '0') para false e NULL para qualquer outro valor * ``toBoolean('true') -> true``
* ``toBoolean('n') -> false``
* ``toBoolean('truthy') -> NULL``
*********************************
### <code>toDate</code>
<code><b>toDate(<i>&lt;string&gt;</i> : any, [<i>&lt;date format&gt;</i> : string]) => date</b></code><br/><br/>
Converte uma cadeia de caracteres para uma data tendo em conta um formato de data opcional. Consulte SimpleDateFormat de Java para todos os formatos possíveis. Se o formato de data for omitido, combinações das seguintes ações são aceites. [ yyyy, yyyy-[M]M, yyyy-[M]M-[d]d, yyyy-[M]M-[d]d, yyyy-[M]M-[d]d, yyyy-[M]M-[d]dT* ] * ``toDate('2012-8-8') -> 2012-8-8``
* ``toDate('12/12/2012', 'MM/dd/yyyy') -> 2012-12-12``
*********************************
### <code>toDecimal</code>
<code><b>toDecimal(<i>&lt;value&gt;</i> : any, [<i>&lt;precision&gt;</i> : integral], [<i>&lt;scale&gt;</i> : integral], [<i>&lt;format&gt;</i> : string], [<i>&lt;locale&gt;</i> : string]) => decimal(10,0)</b></code><br/><br/>
Converte qualquer numérico ou de cadeia de caracteres para um valor decimal. Se precision e scale não forem especificados, este padrão é obtido para (10,2). Um formato decimal opcional do Java pode ser utilizado para a conversão. Um formato de localidade opcional na forma de linguagem de BCP47 como en-US, Alemanha, zh-CN * ``toDecimal(123.45) -> 123.45``
* ``toDecimal('123.45', 8, 4) -> 123.4500``
* ``toDecimal('$123.45', 8, 4,'$###.00') -> 123.4500``
* ``toDecimal('Ç123,45', 10, 2, 'Ç###,##', 'de') -> 123.45``
*********************************
### <code>toDouble</code>
<code><b>toDouble(<i>&lt;value&gt;</i> : any, [<i>&lt;format&gt;</i> : string], [<i>&lt;locale&gt;</i> : string]) => double</b></code><br/><br/>
Converte qualquer numérico ou de cadeia de caracteres com um valor duplo. Um formato decimal opcional do Java pode ser utilizado para a conversão. Um formato de localidade opcional na forma de linguagem de BCP47 como en-US, Alemanha, zh-CN * ``toDouble(123.45) -> 123.45``
* ``toDouble('123.45') -> 123.45``
* ``toDouble('$123.45', '$###.00') -> 123.45``
* ``toDouble('Ç123,45', 'Ç###,##', 'de') -> 123.45``
*********************************
### <code>toFloat</code>
<code><b>toFloat(<i>&lt;value&gt;</i> : any, [<i>&lt;format&gt;</i> : string], [<i>&lt;locale&gt;</i> : string]) => float</b></code><br/><br/>
Converte qualquer numérico ou de cadeia de caracteres para um valor de vírgula flutuante. Um formato decimal opcional do Java pode ser utilizado para a conversão. Trunca qualquer valor de duplo * ``toFloat(123.45) -> 123.45``
* ``toFloat('123.45') -> 123.45``
* ``toFloat('$123.45', '$###.00') -> 123.45``
*********************************
### <code>toInteger</code>
<code><b>toInteger(<i>&lt;value&gt;</i> : any, [<i>&lt;format&gt;</i> : string], [<i>&lt;locale&gt;</i> : string]) => integer</b></code><br/><br/>
Converte qualquer numérico ou de cadeia de caracteres para um valor inteiro. Um formato decimal opcional do Java pode ser utilizado para a conversão. Trunca qualquer comprimento, número de vírgula flutuante, double * ``toInteger(123) -> 123``
* ``toInteger('123') -> 123``
* ``toInteger('$123', '$###') -> 123``
*********************************
### <code>toLong</code>
<code><b>toLong(<i>&lt;value&gt;</i> : any, [<i>&lt;format&gt;</i> : string], [<i>&lt;locale&gt;</i> : string]) => long</b></code><br/><br/>
Converte qualquer numérico ou de cadeia de caracteres para um valor extenso. Um formato decimal opcional do Java pode ser utilizado para a conversão. Trunca qualquer número de vírgula flutuante, double * ``toLong(123) -> 123``
* ``toLong('123') -> 123``
* ``toLong('$123', '$###') -> 123``
*********************************
### <code>toShort</code>
<code><b>toShort(<i>&lt;value&gt;</i> : any, [<i>&lt;format&gt;</i> : string], [<i>&lt;locale&gt;</i> : string]) => short</b></code><br/><br/>
Converte qualquer numérico ou de cadeia de caracteres para um valor curto. Um formato decimal opcional do Java pode ser utilizado para a conversão. Trunca qualquer número inteiro, comprimento, float, duplo * ``toShort(123) -> 123``
* ``toShort('123') -> 123``
* ``toShort('$123', '$###') -> 123``
*********************************
### <code>toString</code>
<code><b>toString(<i>&lt;value&gt;</i> : any, [<i>&lt;number format/date format&gt;</i> : string]) => string</b></code><br/><br/>
Converte um tipo de dados primitivo numa cadeia. Para números e data pode ser especificado um formato. Se não for especificado, a predefinição do sistema é escolhida. Formato decimal é usado para números de Java. Consulte SimpleDateFormat de Java para todos os formatos de data possíveis; o formato de padrão é aaaa-MM-dd * ``toString(10) -> '10'``
* ``toString('engineer') -> 'engineer'``
* ``toString(123456.789, '##,###.##') -> '123,456.79'``
* ``toString(123.78, '000000.000') -> '000123.780'``
* ``toString(12345, '##0.#####E0') -> '12.345E3'``
* ``toString(toDate('2018-12-31')) -> '2018-12-31'``
* ``toString(toDate('2018-12-31'), 'MM/dd/yy') -> '12/31/18'``
* ``toString(4 == 20) -> 'false'``
*********************************
### <code>toTimestamp</code>
<code><b>toTimestamp(<i>&lt;string&gt;</i> : any, [<i>&lt;timestamp format&gt;</i> : string], [<i>&lt;time zone&gt;</i> : string]) => timestamp</b></code><br/><br/>
Converte uma cadeia de caracteres para uma data tendo em conta um formato de timestamp opcional. Consulte SimpleDateFormat de Java para todos os formatos possíveis. Se for omitido o carimbo de hora a predefinição padrão [M] aaaa-M-[d] d hh: mm: [. f....] é utilizado * ``toTimestamp('2016-12-31 00:12:00') -> 2012-8-8T00:12:00``
* ``toTimestamp('2016/12/31T00:12:00', 'MM/dd/yyyyThh:mm:ss') -> 2012-12-12T00:12:00``
*********************************
### <code>toUTC</code>
<code><b>toUTC(<i>&lt;value1&gt;</i> : timestamp, [<i>&lt;value2&gt;</i> : string]) => timestamp</b></code><br/><br/>
Converte o carimbo de hora em UTC. Pode passar um fuso horário opcional na forma de 'GMT', "PST", "UTC", ' América/Caimão'. Padrão é obtido para o fuso horário atual * ``toUTC(currentTimeStamp()) -> 12-12-2030T19:18:12``
* ``toUTC(currentTimeStamp(), 'Asia/Seoul') -> 12-13-2030T11:18:12``
*********************************
### <code>translate</code>
<code><b>translate(<i>&lt;string to translate&gt;</i> : string, <i>&lt;lookup characters&gt;</i> : string, <i>&lt;replace characters&gt;</i> : string) => string</b></code><br/><br/>
Substitua um conjunto de carateres por outro conjunto de caracteres na cadeia de caracteres. Substituição de 1 a 1 de ter carateres * ``translate('(Hello)', '()', '[]') -> '[Hello]'``
* ``translate('(Hello)', '()', '[') -> '[Hello'``
*********************************
### <code>trim</code>
<code><b>trim(<i>&lt;string to trim&gt;</i> : string, [<i>&lt;trim characters&gt;</i> : string]) => string</b></code><br/><br/>
Corta uma cadeia de caracteres à esquerda e à direita. Se o segundo parâmetro é não especificado,-corta espaços em branco. Caso contrário ele corta qualquer caráter especificado no segundo parâmetro * ``trim('!--!wor!ld!', '-!') -> 'wor!ld'``
*********************************
### <code>true</code>
<code><b>true() => boolean</b></code><br/><br/>
Sempre retorna um valor true. Utilize a função syntax(true()) se existir uma coluna chamada 'true' * ``isDiscounted == true()``
* ``isDiscounted() == true``
*********************************
### <code>typeMatch</code>
<code><b>typeMatch(<i>&lt;type&gt;</i> : string, <i>&lt;base type&gt;</i> : string) => boolean</b></code><br/><br/>
Corresponde ao tipo da coluna. Só pode ser utilizado no padrão expressions.number corresponde curto, número inteiro, long, double, vírgula flutuante ou de número decimal, integrante corresponde ao resumo, número inteiro, longas e fracionários correspondências duplas, número de vírgula flutuante, decimal e datetime correspondências data ou timestamp tipo * ``typeMatch(type, 'number') -> true``
* ``typeMatch('date', 'number') -> false``
*********************************
### <code>upper</code>
<code><b>upper(<i>&lt;value1&gt;</i> : string) => string</b></code><br/><br/>
Uppercases uma cadeia de caracteres * ``upper('bojjus') -> 'BOJJUS'``
*********************************
### <code>variance</code>
<code><b>variance(<i>&lt;value1&gt;</i> : number) => double</b></code><br/><br/>
Obtém a variância de uma coluna * ``variance(sales) -> 122.12``
*********************************
### <code>varianceIf</code>
<code><b>varianceIf(<i>&lt;value1&gt;</i> : boolean, <i>&lt;value2&gt;</i> : number) => double</b></code><br/><br/>
Com base num critério, obtém a variância de uma coluna * ``varianceIf(region == 'West', sales) -> 122.12``
*********************************
### <code>variancePopulation</code>
<code><b>variancePopulation(<i>&lt;value1&gt;</i> : number) => double</b></code><br/><br/>
Obtém a variância da população de uma coluna * ``variancePopulation(sales) -> 122.12``
*********************************
### <code>variancePopulationIf</code>
<code><b>variancePopulationIf(<i>&lt;value1&gt;</i> : boolean, <i>&lt;value2&gt;</i> : number) => double</b></code><br/><br/>
Com base num critério, obtém a variância da população de uma coluna * ``variancePopulationIf(region == 'West', sales) -> 122.12``
*********************************
### <code>varianceSample</code>
<code><b>varianceSample(<i>&lt;value1&gt;</i> : number) => double</b></code><br/><br/>
Obtém a povoação não variância de uma coluna * ``varianceSample(sales) -> 122.12``
*********************************
### <code>varianceSampleIf</code>
<code><b>varianceSampleIf(<i>&lt;value1&gt;</i> : boolean, <i>&lt;value2&gt;</i> : number) => double</b></code><br/><br/>
Com base num critério, obtém a povoação não variância de uma coluna * ``varianceSampleIf(region == 'West', sales) -> 122.12``
*********************************
### <code>weekOfYear</code>
<code><b>weekOfYear(<i>&lt;value1&gt;</i> : datetime) => integer</b></code><br/><br/>
Obtém a semana do ano com uma data * ``weekOfYear(toDate('2008-02-20')) -> 8``
*********************************
### <code>xor</code>
<code><b>xor(<i>&lt;value1&gt;</i> : boolean, <i>&lt;value2&gt;</i> : boolean) => boolean</b></code><br/><br/>
Operador XOR lógico. Mesmo que ^ operador * ``xor(true, false) -> true``
* ``xor(true, true) -> false``
* ``true ^ false -> true``
*********************************
### <code>year</code>
<code><b>year(<i>&lt;value1&gt;</i> : datetime) => integer</b></code><br/><br/>
Obtém o valor de ano de uma data * ``year(toDate('2012-8-8')) -> 2012``

## <a name="next-steps"></a>Passos Seguintes

[Saiba como utilizar o construtor de expressões](concepts-data-flow-expression-builder.md).
